import json
import logging
import os

from infra.llms.consts import *
from infra.llms.base import LLMBase
from infra.llms.factory import LlmFactory
from infra.utils.format import strip_markdown_json_flag


def plan_mem_operations(llm: LLMBase, user_name, existing_memories, new_memories):

    prompt = _prompt_dict.get(llm.config.model, _DEFAULT_PROMPT).format(
        user_name=user_name, existing_memories=existing_memories, new_memories=new_memories,
        MEM_OP_DELETE=MEM_OP_DELETE, MEM_OP_ADD=MEM_OP_ADD, MEM_OP_NOOP=MEM_OP_NOOP,
        SOURCE_NODE=SOURCE_NODE, SOURCE_TYPE=SOURCE_TYPE, RELATION=RELATION, DESTINATION_NODE=DESTINATION_NODE, DESTINATION_TYPE=DESTINATION_TYPE)
    # tools = [_tool_description_update.get(llm.config.model, _DEFAULT_TOOL_DESC_UPDATE),
    #          _tool_description_add.get(llm.config.model, _DEFAULT_TOOL_DESC_ADD),
    #          _tool_description_noop.get(llm.config.model, _DEFAULT_TOOL_DESC_NOOP)]

    messages = [
        {
            ROLE: USER,
            CONTENT: prompt,
        },
    ]

    resp = llm.generate_response(
        messages=messages,
        # tools=tools,
    )

    resp = strip_markdown_json_flag(resp)
    memory_operations = json.loads(resp)

    return memory_operations

    # to_be_added = []
    # to_be_deleted = []
    # for item in resp[TOOL_CALLS]:
    #     if item[NAME] == "add_graph_memory":
    #         to_be_added.append(item[ARGUMENTS])
    #     elif item[NAME] == "delete_graph_memory":
    #         to_be_deleted.append(item[ARGUMENTS])
    #     elif item[NAME] == "noop":
    #         continue
    #
    # return to_be_added, to_be_deleted


SOURCE_NODE = "source"
SOURCE_TYPE = "source_type"
RELATION = "relation"
DESTINATION_NODE = "destination"
DESTINATION_TYPE = "destination_type"

MEM_OPERATION = "operation"
MEM_OP_ADD = "ADD"
MEM_OP_DELETE = "DELETE"
MEM_OP_NOOP = "NOOP"

_prompt_dict = dict()
_tool_description_update = dict()
_tool_description_add = dict()
_tool_description_noop = dict()


_DEFAULT_PROMPT = """
You are an AI expert specializing in graph memory (in the form of knowledge graph) management and optimization.
Your task is to analyze existing knowledge graph alongside new information carried by new memories, and update the graph memory to ensure the most accurate, current, and coherent representation of knowledge.
If information contains self reference such as 'I', 'me', 'my' etc. then use {user_name} as the source node. 
The format of existing memories looks like below:
```json{{
    "{SOURCE_NODE}": "Hancy",
    "{SOURCE_TYPE}": ["person"],
    "{RELATION}": "likes",
    "{DESTINATION_NODE}": "playing_football",
    "{DESTINATION_TYPE}": ["sport"]
}}```
This json string means Hancy, who is a person, likes playing football which is a sport.


Input:
1. Existing Graph Memories: A list of current graph memories, each containing source, destination, and relation information.
2. New Graph Memory: Fresh information to be integrated into the existing graph structure.

Compare new graph memories with the existing graph memory and merege them by:
- {MEM_OP_DELETE}: Delete existing graph memories if they conflicts with new graph memories. 
- {MEM_OP_ADD}: Add new graph memories to the memory if they doesn't show up in the existing graph memory, or, override the conflicting existing memories by new memories.
- {MEM_OP_NOOP}: Make no change to the graph memories, which means the existing graph memories contains all the information carried by the new graph memories.

So actually the "Update" operation is done via combining DELETE and ADD operations.

Guidelines:
1. Comprehensive Review: Thoroughly examine each existing graph memory against the new information, updating relationships as necessary. Multiple updates may be required.
2. Consistency: Maintain a uniform and clear style across all memories. Each entry should be concise yet comprehensive.
3. Semantic Coherence: Ensure that updates maintain or improve the overall semantic structure of the graph.
4. Temporal Awareness: If timestamps are available, consider the recency of information when making updates.
5. Relationship Refinement: Look for opportunities to refine relationship descriptions for greater precision or clarity.
6. Redundancy Elimination: Identify and merge any redundant or highly similar relationships that may result from the update.

Task Details:
- Existing Graph Memories:
{existing_memories}

- New Graph Memory: 
{new_memories}

Output:
Provide a list of DELETE/ADD/NONE instructions, each specifying the source, destination, and the relationship to be set.
The output should contain all the information generated by "merging" the existing graph memories and new graph memories.
Provide ***ONLY*** those information which you are very sure of. 
Do not return anything except the JSON format.
"""


# _DEFAULT_TOOL_DESC_UPDATE = {
#     "type": "function",
#     "function": {
#         "name": "delete_graph_memory",
#         "description": "Delete existing graph memories if they conflicts with new graph memories.",
#         "strict": True,
#         "parameters": {
#             "type": "object",
#             "properties": {
#                 "source": {
#                     "type": "string",
#                     "description": "The identifier of the source node in the relationship to be deleted. This should match an existing node in the graph.",
#                 },
#                 "destination": {
#                     "type": "string",
#                     "description": "The identifier of the destination node in the relationship to be deleted. This should match an existing node in the graph.",
#                 },
#                 "relationship": {
#                     "type": "string",
#                     "description": "The relationship between the source and destination nodes. This should match an existing relation in the graph.",
#                 },
#             },
#             "required": ["source", "destination", "relationship"],
#             "additionalProperties": False,
#         },
#     },
# }
#
# _DEFAULT_TOOL_DESC_ADD = {
#     "type": "function",
#     "function": {
#         "name": "add_graph_memory",
#         "description": "Add new graph memories to the memory if they doesn't show up in the existing graph memory",
#         "strict": True,
#         "parameters": {
#             "type": "object",
#             "properties": {
#                 "source": {
#                     "type": "string",
#                     "description": "The identifier of the source node in the new relationship. This can be an existing node or a new node to be created.",
#                 },
#                 "destination": {
#                     "type": "string",
#                     "description": "The identifier of the destination node in the new relationship. This can be an existing node or a new node to be created.",
#                 },
#                 "relationship": {
#                     "type": "string",
#                     "description": "The type of relationship between the source and destination nodes. This should be a concise, clear description of how the two nodes are connected.",
#                 },
#                 "source_type": {
#                     "type": "string",
#                     "description": "The type or category of the source node. This helps in classifying and organizing nodes in the graph.",
#                 },
#                 "destination_type": {
#                     "type": "string",
#                     "description": "The type or category of the destination node. This helps in classifying and organizing nodes in the graph.",
#                 },
#             },
#             "required": [
#                 "source",
#                 "destination",
#                 "relationship",
#                 "source_type",
#                 "destination_type",
#             ],
#             "additionalProperties": False,
#         },
#     },
# }
#
# _DEFAULT_TOOL_DESC_OVERRIDE = {
#     "type": "function",
#     "function": {
#         "name": "override_graph_memory",
#         "description": "Override the conflicting existing memories by new memories.",
#         "strict": True,
#         "parameters": {
#             "type": "object",
#             "properties": {
#                 "source": {
#                     "type": "string",
#                     "description": "The identifier of the source node in the new relationship. This can be an existing node or a new node to be created.",
#                 },
#                 "destination": {
#                     "type": "string",
#                     "description": "The identifier of the destination node in the new relationship. This can be an existing node or a new node to be created.",
#                 },
#                 "relationship": {
#                     "type": "string",
#                     "description": "The type of relationship between the source and destination nodes. This should be a concise, clear description of how the two nodes are connected.",
#                 },
#                 "source_type": {
#                     "type": "string",
#                     "description": "The type or category of the source node. This helps in classifying and organizing nodes in the graph.",
#                 },
#                 "destination_type": {
#                     "type": "string",
#                     "description": "The type or category of the destination node. This helps in classifying and organizing nodes in the graph.",
#                 },
#             },
#             "required": [
#                 "source",
#                 "destination",
#                 "relationship",
#                 "source_type",
#                 "destination_type",
#             ],
#             "additionalProperties": False,
#         },
#     },
# }
#
# _DEFAULT_TOOL_DESC_NOOP = {
#     "type": "function",
#     "function": {
#         "name": "noop",
#         "description": "No operation should be performed to the graph entities. This function is called when the system determines that no changes or additions are necessary based on the current input or context. It serves as a placeholder action when no other actions are required, ensuring that the system can explicitly acknowledge situations where no modifications to the graph are needed.",
#         "strict": True,
#         "parameters": {
#             "type": "object",
#             "properties": {},
#             "required": [],
#             "additionalProperties": False,
#         },
#     },
# }

if __name__ == "__main__":
    config = {
        "api_key": os.environ.get("DASHSCOPE_API_KEY"),
        "model": "qwen-max",
        "temperature": 0.00001,
        "top_p": 0.00001,
        "max_tokens": 1500,
    }
    llm = LlmFactory.create("aliyun", config)


    existing_memories = []
    new_memories = ["My daughter's name is Hancy"]
    memory_operations = plan_mem_operations(llm, "wx", existing_memories, new_memories)
    logging.info(f"{memory_operations=}")

    existing_memories = [
        {
            f"{SOURCE_NODE}": "Hancy",
            f"{SOURCE_TYPE}": "person",
            f"{RELATION}": "likes",
            f"{DESTINATION_NODE}": "football",
            f"{DESTINATION_TYPE}": "sport"
        },
    ]
    new_memories = [
        "Hancy does like playing football",
    ]
    memory_operations = plan_mem_operations(llm, "Xiang", existing_memories, new_memories)
    logging.info(f"{memory_operations=}")

    existing_memories = [
        {
            f"{SOURCE_NODE}": "Hancy",
            f"{SOURCE_TYPE}": "person",
            f"{RELATION}": "likes",
            f"{DESTINATION_NODE}": "football",
            f"{DESTINATION_TYPE}": "sport"
        },
        {
            f"{SOURCE_NODE}": "Shaque Network Inc.",
            f"{SOURCE_TYPE}": "company",
            f"{RELATION}": "located_in",
            f"{DESTINATION_NODE}": "Songjiang District, Shanghai, China",
            f"{DESTINATION_TYPE}": "location"
        }
    ]
    new_memories = [
        "Hancy doesn't like football",
        "Shaque Network Inc. locates in Baoshan District."
    ]
    memory_operations = plan_mem_operations(llm, "Xiang", existing_memories, new_memories)
    logging.info(f"{memory_operations=}")